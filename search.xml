<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello hexo</title>
      <link href="2021/03/19/hello-hexo/"/>
      <url>2021/03/19/hello-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>在老早以前，自己就有搭建一个博客的想法，中途也尝试自己动手操作过，但是好几次都半途而废了。在自己的想法中，一个博客需要一套管理系统，自己没那么多时间。最近在晚上搜寻的时候，发现了一个惊为天人的博客，其UI甚合我意，于是一番操作下发现了这个<a href="http://hexo.io/zh-cn/">Hexo</a>，以及那个深得我心的主题-<a href="https://github.com/TriDiamond/hexo-theme-obsidian">obsidian</a>。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>用人话来讲就是，你只管写自己的markdown，那些高大上的渲染以及兼容我会处理好。啊这。。。</p></blockquote><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="所需工具软件"><a href="#所需工具软件" class="headerlink" title="所需工具软件"></a>所需工具软件</h3><ul><li>git : <a href="http://git-scm.com/">http://git-scm.com/</a></li><li>Nodejs : <a href="http://nodejs.org/">http://nodejs.org/</a></li><li>Hexo ： <a href="http://hexo.io/zh-cn/">http://hexo.io/zh-cn/</a></li></ul><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><ul><li><p>git和Nodejs的安装就不说了。</p></li><li><p>安装Hexo</p><pre><code class="bash">$ npm install -g hexo-cli</code></pre></li><li><p>创建hexo文件夹并进入</p><pre><code class="bash">$ hexo init$ npm install</code></pre></li><li><p>启动Hexo服务</p><pre><code class="bash">$ hexo server</code></pre><blockquote><p>浏览器访问：<a href="http://localhost:4000/%EF%BC%8C%E6%AD%A4%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98">http://localhost:4000/，此时使用的是默认主题</a></p></blockquote></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p>下载主题</p><pre><code class="bash">$ git clone https://github.com/TriDiamond/hexo-theme-obsidian.git obsidian</code></pre></li><li><p>修改_config.yml，启用主题</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f20b587aeb5c49eb983c8be2e2f7641e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><blockquote><p>更多配置项，请参考<a href="https://hexo.io/zh-cn/docs/configuration.html">这里</a></p></blockquote><ul><li><p>安装主题需要的 NPM 依赖</p><pre><code class="bash">$ cd themes/obsidian$ npm install</code></pre></li><li><p>重新启动</p><pre><code class="bash">$ cd hexo$ hexo s</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 初见 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> obsidian </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离 , 如何保证接口安全性 ？</title>
      <link href="2019/09/03/interface-security-design/"/>
      <url>2019/09/03/interface-security-design/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol><li><p><strong>HTTP 请求中的来源识别</strong></p></li><li><p><strong>数据加密</strong></p><p> 采用https协议，保障数据传输过程中的安全</p></li><li><p><strong>数据签名</strong></p><p> 将要提交的数据，通过某种方式组合成一个字符串，然后通过 MD5 算法生成一个签名。如果觉得单纯的 MD5 不够安全的话，还可以在 MD5 的时候加盐和加 hash 。</p></li><li><p><strong>时间戳</strong></p><p> 在参数中加上当前请求的时间戳，服务端拿到这个请求后会拿当前的时间和请求中的时间做比较，比如在 5 分钟之内的才会流转到后面的业务处理，在 5 分钟以外的直接返回错误码。时间戳机制主要用来应对攻击者直接拿包进行非法的 DDOS 攻击。</p></li><li><p><strong>AppID/Token</strong></p><p> 服务端为了验证合法的调用用户，可以添加一个 AppID，或者给登录用户设置token。</p></li><li><p><strong>参数整体加密</strong></p><p> 采用对称加密或者公开密钥算法对请求做一次整体加密，防止在浏览器的 network 中进行抓包。具体做法为：</p><ul><li>前端生成随机数作为签名key，用于对请求数据进行对称加密</li><li>前端使用RSA的公钥对key进行加密</li><li>将公钥作为头传递给服务器</li></ul></li><li><p><strong>限流</strong></p><p> 服务端针对接口进行限流，限流的算法常见的有这么几种：令牌桶限流、漏桶限流、计数器限流。</p></li><li><p><strong>黑名单</strong></p></li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p><strong>压缩</strong></p><p> 代码压缩，去除 JavaScript 代码中不必要的空格、换行等内容，把一些可能公用的代码进行处理实现共享，最后输出的结果都压缩为一行或者几行内容，降低代码可读性。</p></li><li><p><strong>混淆</strong></p><p> JavaScript 混淆器大致有两种:通过正则替换实现的混淆器、通过语法树替换实现的混淆器。</p></li><li><p><strong>加密</strong></p><p> 将一些核心逻辑使用诸如 C/C++ 语言来编写，并通过 JavaScript 调用执行，从而起到二进制级别的防护作用。其加密的方式现在有 Emscripten 和 WebAssembly 等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 接口设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之LockSupport</title>
      <link href="2019/08/23/locksupport/"/>
      <url>2019/08/23/locksupport/</url>
      
        <content type="html"><![CDATA[<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport提供的park/unpark是以线程的角度来设计，真正解耦了线程之间的同步。</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul><li><p>park()方法，对当前线程执行阻塞操作，直到获取到可用许可后才解除阻塞，也就相当于当前线程进入阻塞状态。</p><blockquote><p>park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法。park不会释放当前线程占有的锁资源。</p></blockquote></li><li><p>parkNanos(long)方法，对当前线程执行阻塞操作，等待获取到可用许可后才解除阻塞，最大的等待时间由传入的参数来指定，一旦超过最大时间它也会解除阻塞。</p></li><li><p>parkUntil(long)方法，，对当前线程执行阻塞操作，等待获取到可用许可后才解除阻塞，最大的等待时间为参数所指定的最后期限时间。</p></li><li><p>park(Object)方法，与park()方法同义，但它多传入的参数为阻塞对象。</p></li><li><p>parkNanos(Object,long)方法，与parkNanos(long)同义，但指定了阻塞对象。</p></li><li><p>parkUntil(Object,long)方法，与parkUntil(long)同义，但指定了阻塞对象。</p></li><li><p>unpark(Thread)方法，将指定线程的许可置为可用，也就相当于唤醒了该线程。</p></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595760109ebf41a6912cdd6634c0e7e1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="许可机制"><a href="#许可机制" class="headerlink" title="许可机制"></a>许可机制</h2><p>对于LockSupport使用的许可可看成是一种二元信号，该信号分有许可和无许可两种状态。每个线程都对应一个信号变量，当线程调用park时其实就是去获取许可，如果能成功获取到许可则能够往下执行，否则则阻塞直到成功获取许可为止。而当线程调用unpark时则是释放许可，供线程去获取。park/unpark方式的执行顺序不影响唤醒，不会造成死锁。</p><h2 id="park-对立中断的响应"><a href="#park-对立中断的响应" class="headerlink" title="park 对立中断的响应"></a>park 对立中断的响应</h2><p>park方法支持中断，也就是说一个线程调用park方法进入阻塞后，如果该线程被中断则能够解除阻塞立即返回。但需要注意的是，它不会抛出中断异常，所以我们不必去捕获InterruptedException。</p><h2 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h2><ul><li>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来；LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li><li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；LockSupport.park()方法不需要捕获中断异常；</li></ul><h2 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h2><ul><li>Object.wait()方法需要在synchronized块中执行；LockSupport.park()可以在任意地方执行；</li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；LockSupport.park()不需要捕获中断异常；</li><li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</li><li>如果在wait()之前执行了notify()会抛出IllegalMonitorStateException异常；</li><li>如果在park()之前执行了unpark()线程不会被阻塞，直接跳过park()，继续执行后续内容；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> park </tag>
            
            <tag> locksupport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之AQS原理剖析</title>
      <link href="2019/07/17/aqs-principle-analyzing/"/>
      <url>2019/07/17/aqs-principle-analyzing/</url>
      
        <content type="html"><![CDATA[<h2 id="AQS的类图结构"><a href="#AQS的类图结构" class="headerlink" title="AQS的类图结构"></a>AQS的类图结构</h2><p>AQS全称是AbstractQueuedSynchronizer，即抽象同步队列。下面看一下AQS的类图结构：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d0dbf4618d94f21b2ec8a164b94ee5f~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h2><p>在AQS中维持了一个volatile修饰的单一共享状态state，来实现同步器同步。其更新采用乐观锁思想的CAS算法。</p><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>CLH(Craig, Landin, and Hagersten locks) 同步队列 是一个FIFO双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的类型为Node。AQS依赖它来完成同步状态state的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc33acab7cd4d3f93eb7e0d39401e41~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），condition队列的后续节点（nextWaiter）如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17356b0676d04ae89af1aa71a882cc54~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>waitStatus几种状态状态：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5695bba83d344806ac51f95f22fed27d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>CLH队列入列就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。addWaiter方法如下：</p><pre><code>//构造Nodeprivate Node addWaiter(Node mode) &#123;    Node node = new Node(Thread.currentThread(), mode);    // Try the fast path of enq; backup to full enq on failure    Node pred = tail;    if (pred != null) &#123;        node.prev = pred;        //CAS设置尾节点        if (compareAndSetTail(pred, node)) &#123;            pred.next = node;            return node;        &#125;    &#125;    //多次尝试    enq(node);    return node;&#125;</code></pre><p>addWaiter设置尾节点失败的话，调用enq(Node node)方法设置尾节点，enq方法如下：</p><pre><code>private Node enq(final Node node) &#123;    //死循环    for (;;) &#123;        Node t = tail;        //tail不存在，则设置为首节点        if (t == null) &#123; // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点。可以看以下源码：</p><pre><code>private void unparkSuccessor(Node node) &#123;    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    if (s != null)        LockSupport.unpark(s.thread);&#125;</code></pre><p>acquire方法流程如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9492d932f01c44079f545e836e202597~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="独占与共享模式"><a href="#独占与共享模式" class="headerlink" title="独占与共享模式"></a>独占与共享模式</h2><p>AQS支持两种同步模式:独占式和共享式。</p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>同一时刻仅有一个线程持有同步状态，如ReentrantLock。又可分为公平锁和非公平锁。</p><ul><li>公平锁： 按照线程在队列中的排队顺序，有礼貌的，先到者先拿到锁。</li><li>非公平锁： 当线程要获取锁时，无视队列顺序直接去抢锁，不讲道理的，谁抢到就是谁的。</li></ul><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>多个线程可同时执行，如Semaphore/CountDownLatch等都是共享式的产物。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903903188746247">https://juejin.cn/post/6844903903188746247</a></p>]]></content>
      
      
      <categories>
          
          <category> AQS </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> CLH </tag>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之死锁、活锁、饥饿</title>
      <link href="2019/06/10/locks/"/>
      <url>2019/06/10/locks/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><ul><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li></ul><h3 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h3><p>使用jstack或者jconsole可查看线程堆栈。</p><pre><code>&quot;Thread-1&quot; prio=10 tid=0x00007fe8c00a0800 nid=0x17cc waiting for monitor entry [0x00007fe8c5031000]   java.lang.Thread.State: BLOCKED (on object monitor)        at DeadLocakTest$DeadThread2.run(DeadLocakTest.java:61)        - waiting to lock &lt;0x00000000af24b248&gt; (a java.lang.Object)        - locked &lt;0x00000000af24b258&gt; (a java.lang.Object)        at java.lang.Thread.run(Thread.java:745)    Locked ownable synchronizers:        - None &quot;Thread-0&quot; prio=10 tid=0x00007fe8c009e800 nid=0x17cb waiting for monitor entry [0x00007fe8c5132000]   java.lang.Thread.State: BLOCKED (on object monitor)        at DeadLocakTest$DeadThread1.run(DeadLocakTest.java:38)        - waiting to lock &lt;0x00000000af24b258&gt; (a java.lang.Object)        - locked &lt;0x00000000af24b248&gt; (a java.lang.Object)        at java.lang.Thread.run(Thread.java:745)    Locked ownable synchronizers:        - None</code></pre><p>Thread-1</p><blockquote><p>locked <strong>&lt;0x00000000af24b258&gt;</strong><br>waiting to lock <strong>0x00000000af24b248</strong></p></blockquote><p>Thread-0 </p><blockquote><p>locked <strong>0x00000000af24b248</strong><br>waiting to lock <strong>0x00000000af24b258</strong></p></blockquote><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：按序申请资源，反序释放资源。</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁指的是 任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>为解决活锁可以引入一些随机性，例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。典型的例子是以太网的CSMA/CD检测机制。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求…，T2可能永远等待。</p>]]></content>
      
      
      <categories>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 饥饿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之上下文切换</title>
      <link href="2019/05/15/context-switch/"/>
      <url>2019/05/15/context-switch/</url>
      
        <content type="html"><![CDATA[<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><h2 id="上下文切换性能消耗在哪里？"><a href="#上下文切换性能消耗在哪里？" class="headerlink" title="上下文切换性能消耗在哪里？"></a>上下文切换性能消耗在哪里？</h2><p>上下文切换过高，会导致CPU像个搬运工，频繁在寄存器和运行队列直接奔波  ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核 cache之间的共享数据。 </p><h2 id="如何查看上下文切换次数和时长"><a href="#如何查看上下文切换次数和时长" class="headerlink" title="如何查看上下文切换次数和时长"></a>如何查看上下文切换次数和时长</h2><ul><li>使用Lmbench可以测量上下文切换的时长。</li><li>使用vmstat可以测量上下文切换的次数。</li></ul><h2 id="引起上下文切换的原因有哪些？"><a href="#引起上下文切换的原因有哪些？" class="headerlink" title="引起上下文切换的原因有哪些？"></a>引起上下文切换的原因有哪些？</h2><ul><li>对于抢占式操作系统而言， 大体有几种：</li><li>当前任务的时间片用完之后，系统CPU正常调度下一个任务；</li><li>当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；</li><li>多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；</li><li>用户代码挂起当前任务，让出CPU时间；</li><li>硬件中断；</li></ul><h2 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h2><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。❑</p><ul><li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 上线文切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础之HashMap与ConcurrentHashMap重点解读</title>
      <link href="2019/05/05/hashmap-concurrenthashmap-key-point/"/>
      <url>2019/05/05/hashmap-concurrenthashmap-key-point/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><table><thead><tr><th>HashMap</th><th>说明</th></tr></thead><tbody><tr><td>底层结构</td><td>1. JDK1.8之前：数组+链表<br/>2. JDK1.8：数组+链表/红黑树<br/>链表与红黑树之间的转换：<br/>链表-&gt;红黑树：链表长度大于等于8且数组长度（hash桶）大于等于64的时候<br/>红黑树-&gt;链表：红黑树的节点数量小于等于6的时候退化为链表</td></tr><tr><td>元素特性</td><td>key、value可以为null，只能有一个key为null的键值对，允许有多个value为null的键值对</td></tr><tr><td>hash桶的数量</td><td>默认16，加载因子默认0.75（HashMap也许是按照lazy-load原则，在首次put元素时在resize()方法中初始化）</td></tr><tr><td>扰动函数</td><td>1. JDK1.8之前扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算<br/>2. JDK1.8扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>插入过程</td><td>1. 通过key的hashCode经过扰动函数处理过后得到hash值，然后对数组长度取模((n-1)&amp;hash)得到数组下标<br/>2. 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组<br/>3. 如果产生hash冲突，先利用equals进行比较，相同则取代该元素，不同，则判断链表高度插入链表（拉链法），链表高度达到8且数组长度到64则转表为红黑树，以减少搜索时间，长度低于6将红黑树转回链表<br/>4. key为null，存在下标为0的位置</td></tr><tr><td>扩容</td><td>首先检测数组里元素个数(hash桶的大小)，当大于16*0.75=12的时候就会触发扩容，<strong>扩容成之前hash桶数量的2倍(2的幂)</strong><br/>会把之前那些元素再次进行一次哈希运算然后添加到新的hash桶里面，按照链表或红黑树的方式再排列起来</td></tr><tr><td>线程安全性</td><td>非线程安全<br/>在插入操作的时候多线程情况下会有数据覆盖的可能<br/>1.7：在put的时候还有个resize的过程，头插可能会形成一个环形链表导致死循环<br/>1.8：改成尾插，解决了死循环问题，但仍然不建议在多线程环境下使用HashMap</td></tr><tr><td>hash桶的数量为什么是2的幂次方？</td><td>1. 为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的<br/>2. 但是我们不可能开辟一个长度为40亿的数组，用之前还要先对数组的长度取模运算，得到的余数才能用作数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。只有满足2的幂次方，(n - 1) &amp; hash才能映射到0<del>(n-1)的范围内，例如hash桶的默认大小为n=16，n-1=15对应的二进制为0111,只有2的倍数在减1的时候才会出现0111这样的值，才能把hash值映射到0</del>15</td></tr><tr><td>为什么是<code>(n-1)&amp;hash</code>？</td><td>取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；），并且 采用位操作 &amp;，相对于%能够提高运算效率</td></tr><tr><td>为什么要树化？</td><td>链表查询是线性的，会严重影响存取性能，树实现可以提供可靠的O(logn)访问性能</td></tr></tbody></table><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><table><thead><tr><th>HashMap</th><th>说明</th></tr></thead><tbody><tr><td>底层结构</td><td>1. JDK1.7：分段数组+链表<br/>2. JDK1.8：改成了与HashMap一样的数据结构(数组+链表/红黑树)，使用synchronized+CAS来保证线程安全</td></tr><tr><td>扰动函数</td><td>同hashmap相似，1.8多了一个&amp;操作保证hash为正数</td></tr><tr><td>实现线程安全的方式</td><td>1. JDK1.7：对整个桶数组进行了分段分割，加Segment分段锁(继承了ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，并发度为分段个数（可以通过构造函数指定），数组扩容不会影响到其他的Segment<br/>2. JDK1.8：直接用Node数组+链表/红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作，Node的val和next都用volatile修饰，保证可见性<br/>CAS：查找、替换、赋值操作都使用CAS<br/>synchronized：锁链表的头结点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有读写操作，并发扩容</td></tr><tr><td>元素查询</td><td>1. JDK1.7：二次hash，第一次hash定位到Segment，第二次hash定位到元素所在链表的头部<br/>2. JDK1.8：读操作无锁，Node的val和next都用volatile修饰，读写线程对该变量互相可见，数组用volatile修饰，保证扩容时被读线程感知</td></tr></tbody></table><blockquote><p>JDK1.8：hash的时候会 &amp; HASH_BITS，用以保证其为正数。因为ConcurrentHashMap中会利用负值hash做特殊标识。</p></blockquote><ul><li>Java8 ConcurrentHashMap 存储结构：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdb9e8acbb74be086133c6e6a049860~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/xylitolz/article/details/114576106">https://blog.csdn.net/xylitolz/article/details/114576106</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
            <tag> concurrenthashmap </tag>
            
            <tag> 扰动函数 </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之intern方法</title>
      <link href="2019/04/28/string-intern/"/>
      <url>2019/04/28/string-intern/</url>
      
        <content type="html"><![CDATA[<h2 id="intern方法有什么用"><a href="#intern方法有什么用" class="headerlink" title="intern方法有什么用"></a>intern方法有什么用</h2><p>String.intern() 方法可以使得所有含相同内容的字符串都共享同一个内存对象。</p><p>JVM 中，存在一个字符串常量池，字符串的值都存放在这个池中。当调用 intern 方法时，如果字符串常量池中已经存在该字符串，那么返回池中的字符串；否则将此字符串添加到字符串常量池中，并返回字符串的引用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>JDK1.6 中，常量池在方法区。JDK1.7 中，常量池移到堆区了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51bb977cd06f4654b4ba05c66d775d61~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><ul><li>字符串常量池有该字符串，则返回字符串常量池中的引用。</li><li>字符串常量池没有该字符串，会拷贝字符串至字符串常量池。</li></ul><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>字符串常量池有该字符串，则返回字符串常量池中的引用。</li><li>字符串常量池没有该字符串，生成一个对该字符串的引用在字符串常量池</li></ul><h2 id="show-code"><a href="#show-code" class="headerlink" title="show code"></a>show code</h2><pre><code>    String str1 = &quot;java&quot;;    String str2 = &quot;java&quot;;    System.out.println(&quot;str1==str2:&quot; + (str1 == str2));    String str3 = new String(&quot;java&quot;);    System.out.println(&quot;str1==str3: &quot; + (str1 == str3));    System.out.println(&quot;str1==str3.intern(): &quot; + (str1 == str3.intern()));    System.out.println(&quot;str2==str3.intern(): &quot; + (str2 == str3.intern()));    String str4 = new String(&quot;java&quot;);    System.out.println(&quot;str3==str4: &quot; + (str3 == str4));    System.out.println(&quot;str3.intern()==str4.intern(): &quot; + (str3.intern() == str4.intern()));    String str5 = new StringBuilder(&quot;String&quot;).append(&quot;intern&quot;).toString();    System.out.println(&quot;str5.intern() == str5: &quot; + (str5.intern() == str5));    String str6 = new String(new StringBuilder(&quot;hei&quot;).append(&quot;lou&quot;).toString());    System.out.println(&quot;str6.intern() == str6: &quot; + (str6.intern() == str6));    String str7 = new String(&quot;hei&quot;);    System.out.println(&quot;str7.intern() == str7: &quot; + (str7.intern() == str7));</code></pre><p>1.8与1.6输出结果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59b9af923244433897eb3a1890516547~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> intern </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis专题-热点key解决方案</title>
      <link href="2019/04/20/redis-hot-key/"/>
      <url>2019/04/20/redis-hot-key/</url>
      
        <content type="html"><![CDATA[<h2 id="热Key问题"><a href="#热Key问题" class="headerlink" title="热Key问题"></a>热Key问题</h2><p>热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。</p><h2 id="如何发现热key"><a href="#如何发现热key" class="headerlink" title="如何发现热key"></a>如何发现热key</h2><ol><li>凭借业务经验，进行预估哪些是热key</li><li>在客户端进行收集<br> 在操作redis之前，加入一行代码进行数据统计。</li><li>在Proxy层做收集<br> <img src="https://img-blog.csdnimg.cn/2021032622085766.png"></li><li>用redis自带命令<ul><li>monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</li><li>hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</li></ul></li><li>自己抓包评估</li></ol><h2 id="热key解决"><a href="#热key解决" class="headerlink" title="热key解决"></a>热key解决</h2><ol><li><p>利用二级缓存<br>比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。</p></li><li><p>备份热key<br>在key上加上随机数，在多个redis上都存一份。<br><img src="https://img-blog.csdnimg.cn/20210326221531530.png"></p></li></ol><h2 id="业内解决方案"><a href="#业内解决方案" class="headerlink" title="业内解决方案"></a>业内解决方案</h2><h5 id="有赞透明多级缓存解决方案（TMC）"><a href="#有赞透明多级缓存解决方案（TMC）" class="headerlink" title="有赞透明多级缓存解决方案（TMC）"></a>有赞透明多级缓存解决方案（TMC）</h5><p><img src="https://img-blog.csdnimg.cn/20210326222300277.png"></p><ul><li>Jedis-Client： Java 应用与缓存服务端交互的直接入口，接口定义与原生 Jedis-Client 无异；</li><li>Hermes-SDK：自研“热点发现+本地缓存”功能的SDK封装， Jedis-Client 通过与它交互来集成相应能力；</li><li>Hermes服务端集群：接收 Hermes-SDK 上报的缓存访问数据，进行热点探测，将热点 key 推送给 Hermes-SDK 做本地缓存；</li><li>缓存集群：由代理层和存储层组成，为应用客户端提供统一的分布式缓存服务入口；</li><li>基础组件： etcd 集群、 Apollo 配置中心，为 TMC 提供“集群推送”和“统一配置”能力；</li></ul><blockquote><p>源自：<a href="https://segmentfault.com/a/1190000017142556">https://segmentfault.com/a/1190000017142556</a></p></blockquote><h5 id="读写分离架构"><a href="#读写分离架构" class="headerlink" title="读写分离架构"></a>读写分离架构</h5><p><img src="https://img-blog.csdnimg.cn/20210326222822520.png"></p><p>架构中个节点的作用：<br>1）SLB层做负载均衡<br>2）Proxy层做读写分离自动路由<br>3）Master负责写<br>4）ReadOnly节点负责读请求<br>5）Slave节点和Master节点做高可用</p><h5 id="热点数据解决方案"><a href="#热点数据解决方案" class="headerlink" title="热点数据解决方案"></a>热点数据解决方案</h5><p><img src="https://img-blog.csdnimg.cn/20210326222902854.png"></p><p>Proxy架构的主要优点有：<br>1）Proxy缓存热点，读能力可水平扩展<br>2）DB自动计算热点Key<br>3）对客户端完全透明，不需要做任何兼容</p><p>DB计算热点时，主要运用的方法和优势有：<br>1）基于统计阀值的热点统计。<br>2） 基于统计周期的热点统计。<br>3） 基于版本号实现的无需重置初值统计方法。</p><blockquote><p>源自：<a href="https://developer.aliyun.com/article/404817">https://developer.aliyun.com/article/404817</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> hot key </tag>
            
            <tag> TMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis专题-必知必会的基础知识</title>
      <link href="2019/04/15/redis-basic-knowledge/"/>
      <url>2019/04/15/redis-basic-knowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis有哪些优缺点？"><a href="#Redis有哪些优缺点？" class="headerlink" title="Redis有哪些优缺点？"></a>Redis有哪些优缺点？</h2><p>优点</p><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。<br>缺点</li><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</li><li>数据结构简单，读取速度快。比如SDS、双端链表、压缩链表、跳跃链表。</li><li>处理网络请求采用单线程，避免了不必要的上下文切换和竞争条件。<blockquote><p>Redis 4.0 开始，用异步线程处理一些耗时操作。如，异步线程实现惰性删除（解决大KEY删除阻塞主线程）、异步 AOF （解决磁盘 IO 紧张时，fsync 执行一次很慢）等等。</p></blockquote></li><li>使用多路 I/O 复用模型，非阻塞 IO。</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul><h2 id="Redis中有多少数据库？"><a href="#Redis中有多少数据库？" class="headerlink" title="Redis中有多少数据库？"></a>Redis中有多少数据库？</h2><p>Redis服务器默认会创建16个数据库，可通过配置的database选项修改。默认情况下，Redis客户端的目标数据库为0号数据库。</p><h2 id="Redis数据结构？"><a href="#Redis数据结构？" class="headerlink" title="Redis数据结构？"></a>Redis数据结构？</h2><ul><li>基本数据类型：string、list、set、zset、hash</li><li>高级数据结构： Bitmap、HyperLogLog、GEO<blockquote><p>Redis Module：BloomFilter、RedisSearch、Redis-ML、JSON。Stream功能（5.0新增）</p></blockquote></li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>数据缓存</li><li>会话缓存</li><li>时效性数据</li><li>访问频率</li><li>计数器</li><li>社交列表</li><li>记录用户判定信息</li><li>交集、并集和差集</li><li>热门列表与排行榜</li><li>最新动态</li><li>消息队列</li><li>分布式锁</li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis 提供了两种方式，实现数据的持久化到硬盘。Redis启动会优先加载AOF文件，当未开启AOF时，才会加载RDB文件（未开启也不会加载）。</p><p><strong>RDB 持久化（全量）</strong>，fork 一个子进程，将内存中指定时间间隔内的数据集快照写入临时文件，成功后，再替换之前的文件，用二进制压缩存储。通过配置<code>save</code>参数、<code>save</code>（阻塞）、<code>bgsave</code>、<code>shutdown</code>、<code>flushall</code>命令触发。</p><ul><li><p>优点：灵活设置备份频率和周期，适合冷备份，数据集的时候易恢复，子进程持久化不会影响主进程IO。</p></li><li><p>缺点：丢失数据窗口大，当数据集较大时，fork子进程可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟</p></li></ul><blockquote><p>不建议在主 Redis 节点开启 RDB 功能，会带来一定时间的阻塞，特别是数据量大的时候</p></blockquote><p><strong>AOF持久化（增量）</strong>，以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区，然后根据对应的策略向硬盘中同步数据。随着文件越来越大，需要定期对AOF文件进行重写（fork子进程来完成）。配置<code>appendonly yes</code>开启AOF。</p><blockquote><p>AOF文件的加载需要先创建一个伪客户端，然后把命令一条条发送给Redis服务端，服务端再完整执行一遍相应的命令。</p></blockquote><ul><li><p>写入策略：配置<code>appendsync</code> ，每秒同步（<code>everysec</code>），等到缓冲区满才同步（<code>no</code>），每次发生数据变更立即同步（<code>always</code>）。</p></li><li><p>重写机制：通过<code>auto-aof-rewrite-min-size</code>、<code>auto-aof-rewrite-percentage</code>配置重写时机。重写只会保留最终数据，多条写命令会合并为一条，已经超时的数据不会写入文件。重写过程中父进程执行的命令会通过管道按批次发送给子进程，由子进程重写回放。子进程退出后只有少量命令还累计在父进程，父进程只需回放少量命令即可。</p></li><li><p>优点：更高的数据安全性，采用append模式没有磁盘寻址的开销，写入性能非常高，而且也不会破坏已经保存的数据。</p></li><li><p>缺点：AOF文件通常要大于RDB文件，大数据集恢复是其速度慢于RDB，AOF这种较为复杂的基于命令日志/merge/回放的方式容易出bug</p></li></ul><blockquote><p>在 Redis4.0 版本开始，允许使用<code>RDB-AOF</code>混合持久化方式(5.0默认开启)。优化重写机制，重写后新的AOF文件前半段是RDB格式全量数据，后半段是AOF格式增量数据。在 Redis 实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p></blockquote><h2 id="Redis数据过期策略"><a href="#Redis数据过期策略" class="headerlink" title="Redis数据过期策略"></a>Redis数据过期策略</h2><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。对CPU不友好。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</li></ul><blockquote><p>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。Redis中同时使用了惰性过期和定期过期两种过期策略。</p></blockquote><h2 id="Redis数据淘汰策略"><a href="#Redis数据淘汰策略" class="headerlink" title="Redis数据淘汰策略"></a>Redis数据淘汰策略</h2><p>Redis内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。Redis 提供了以下8种数据淘汰策略：</p><ul><li>全局的键空间选择性移除<ul><li>noeviction：新写入操作会报错。（默认）</li><li>allkeys-lru：在键空间中，移除最久未使用的key。（这个是最常用的）</li><li>allkeys-random：在键空间中，随机移除某个key。</li><li>allkeys-lfu：在键空间中，移除最少使用频次的key（4.0的）</li></ul></li><li>设置过期时间的键空间选择性移除<ul><li>volatile-lru：在设置了过期时间的键空间中，移除最久未使用的key。</li><li>volatile-random：在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li><li>volatile-lfu：在设置了过期时间的键空间中，移除最少使用频次的key（4.0的）</li></ul></li></ul><p>LRU：并不是一个严格的 LRU 实现，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p><blockquote><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？选择 allkeys-lru 策略。如果在 Redis 4.0 版本，可以考虑使用 volatile-lfu</p></blockquote><h3 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的 key 过期时间设置的过于集中，一般需要在时间上加一个随机值，使得过期时间分散一些。调大 hz 参数。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。没有隔离级别的概念。事务中任意命令执行失败，其余命令仍会被执行。</p><p>通过<code>MULTI</code>命令开启一个事务，在该语句之后执行的命令，都将被视为事务之内的操作，最后我们可以通过执行 <code>EXEC</code>/<code>DISCARD</code>命令来提交/回滚该事务内的所有操作。开启事务后，所有语句，发送给 Redis Server ，都会暂存在 Server 中。在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。</p><h3 id="如何实现-Redis-CAS-操作？"><a href="#如何实现-Redis-CAS-操作？" class="headerlink" title="如何实现 Redis CAS 操作？"></a>如何实现 Redis CAS 操作？</h3><p>在 Redis 的事务中，<code>WATCH</code>命令可用于提供CAS功能。</p><h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd437e239af4ddfa337ec55869596ca~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/127e179b7d9345ad96c731026b31048c~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>redis cluster采用数据分片的哈希槽来进行数据存储和数据的读取。redis cluster的新增和删除节点都需要手动来分配槽区。redis cluster执行读写操作的都是master节点。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ce2d862fac4edfb35d9dd0a8b94a31~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9e845198a3547f38ce460cedd579c9f~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f69c23f2b0934183bf492ba0906dc996~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。还可使用blpop，在没有消息的时候，它会阻塞住直到消息到来。使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。但是在消费者下线的情况下，生产的消息会丢失。</p><p>延时队列： 使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Redis设计与实现》（黄健宏）</li><li><a href="https://www.processon.com/view/5f7fc48b1e085307a07da543#map">https://www.processon.com/view/5f7fc48b1e085307a07da543#map</a></li><li><a href="http://svip.iocoder.cn/Redis/Interview/">http://svip.iocoder.cn/Redis/Interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> redis集群 </tag>
            
            <tag> 哨兵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构</title>
      <link href="2019/04/10/redis-base-data-structure/"/>
      <url>2019/04/10/redis-base-data-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99f86da38c04d69b8ec536dc18e2cce~tplv-k3u1fbpfcp-zoom-1.image"></p><p>相较于C字符串的优点：</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出。C字符串不记录自身长度容易造成缓冲区溢出，<code>SDS</code>修改时，API会自动将<code>SDS</code>的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</li><li>减少修改字符串时带来的内存重分配次数。<code>SDS</code>采用空间预分配（<code>增长操作</code>）和惰性释放（<code>缩短操作</code>）</li><li>二进制安全。C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。<code>SDS</code>可以保存任意格式的二进制数据。</li><li>兼容部分C字符串函数，避免了不必要的代码重复。</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表被广泛用于实现Redis的各种功能，比如列表、发布与订阅、慢查询、监视器等。</p><p><code>listNode</code>结构：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e12c7c8de42429ea58227a4a6d0c50a~tplv-k3u1fbpfcp-zoom-1.image"></p><p>多个listNode可以通过prev和next指针组成双端链表。</p><p><code>list</code>结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0a259d12fb64aeeab93a15e17d45b14~tplv-k3u1fbpfcp-zoom-1.image"></p><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>一个list结构和三个listNode结构组成的链表：</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887260df9ff64595af3e3c5e95161b8c~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表</p></blockquote><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis的字典使用哈希表作为底层实现，哈希表结构如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68011abde49341be901285c26f318d51~tplv-k3u1fbpfcp-zoom-1.image"></p><p>一个大小为4的空哈希表（没有包含任何键值对）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd8fe7761a94fb9b93f3f1fb7f19c2f~tplv-k3u1fbpfcp-zoom-1.image"></p><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ce0dcb537494dd5beba88a80ea2c2ac~tplv-k3u1fbpfcp-zoom-1.image"></p><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p><p>Redis中的字典的结构：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9833d98c574a0b8f71ff43e16ce3f9~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><ul><li><code>type</code>属性是一个指向<code>dictType</code>结构的指针，每个<code>dictType</code>结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li><code>privdata</code>属性则保存了需要传给那些类型特定函数的可选参数。</li></ul></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>为了避免rehash对服务器性能造成影响，服务器不是一次性将哈希表中所有键值对全部rehash到新的哈希表，而是分多次、渐进式地将完成rehash。</p><p>以下是哈希表渐进式rehash的详细步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><blockquote><p>在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。新添加到字典的键值对一律会被保存到ht[1]里面。</p></blockquote><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（<code>skiplist</code>）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。Redis使用跳跃表作为有序集合键的底层实现之一。</p><p><code>zskiplistNode</code>结构如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65aec15a9cf649d98c5dad5237a75b60~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><ul><li>level：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在下面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>backward指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>obj：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul></blockquote><p><code>zskiplist</code>结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7238607e6544338799ccc424ec686d~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul></blockquote><p>带有zskiplist结构的跳跃表</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12c991edc344472a99551446c4ac15b0~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（<code>intset</code>）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。整数集合结构如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d155c452e8b94235ab129aaca98d062d~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。不支持降级操作。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（<code>ziplist</code>）是列表和哈希的底层实现之一。当一个列表只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表的底层实现。压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。压缩表组成部分：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d5b5e9025c43f880ee12fc4f9a6c68~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><ul><li>zlbytes：记录整个压缩列表占用的内存字节数。在对压缩列表进行内存重分配或者计算zlend的位置时使用。</li><li>zltails：记录压缩列表表尾结点距离压缩列表的起始地址有多少字节。通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾结点的地址。</li><li>zllen：记录了压缩列表包含的节点数量。</li><li>entryX：压缩列表所包含的节点。</li><li>zlend：用于标记压缩列表的末端。</li></ul></blockquote><p>下图展示一个压缩列表的示例：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2430bbbc3fc54718980a91f249023e70~tplv-k3u1fbpfcp-zoom-1.image"></p><p>压缩列表节点：<code>由previous_entry_length</code>、<code>encoding</code>、<code>content</code>三个部分组成。</p><blockquote><ul><li>previous_entry_length：记录了压缩列表中前一个节点的长度。程序可以通过指针减去当前节点的previous_entry_length，来计算出前一个节点的起始地址。</li><li>encoding：记录了节点的content属性所保存数据的类型以及长度。</li><li>content：保存节点的值。节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</li></ul></blockquote><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，e1至eN的所有节点的previous_entry_length属性都是1字节长的（因为所有节点的长度都小于254字节）。这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点，后面的e1,、e2、e3的previous_entry_length都需要程序对压缩列表执行空间重分配，扩展其长度。Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48bfd730c6e14db2b28f280bbf2c4ca3~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</p></blockquote><h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p><code>quicklist</code>中每一个节点都是一个<code>quicklistNode</code>对象，其数据结构定义为：</p><pre><code>typedef struct quicklistNode &#123;    struct quicklistNode *prev;//前一个节点    struct quicklistNode *next;//后一个节点    unsigned char *zl;//当前指向的ziplist或者quicklistLZF    unsigned int sz;//当前ziplist占用字节    unsigned int count : 16;//ziplist中存储的元素个数，16字节(最大65535个)    unsigned int encoding : 2; //是否采用了LZF压缩算法压缩节点 1：RAW 2:LZF    unsigned int container : 2; //存储结构，NONE=1, ZIPLIST=2    unsigned int recompress : 1; //当前ziplist是否需要再次压缩(如果前面被解压过则为true，表示需要再次被压缩)    unsigned int attempted_compress : 1;//测试用     unsigned int extra : 10; //后期留用&#125; quicklistNode;</code></pre><pre><code>typedef struct quicklist &#123;    quicklistNode *head;//列表头节点    quicklistNode *tail;//列表尾节点    unsigned long count;//ziplist中一共存储了多少元素，即:每一个quicklistNode内的count相加    unsigned long len; //双向链表的长度，即quicklistNode的数量    int fill : 16;//填充因子    unsigned int compress : 16;//压缩深度 0-不压缩&#125; quicklist;</code></pre><p>根据这两个结构，我们可以得到Redis3.2之后的列表对象的一个简图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3e20fef98e48868db4a2a48670ec51~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis基于底层数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。Redis的对象系统还实现了基于引用计数技术的内存回收机制和对象共享机制。</p><p>Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。键总是一个字符串对象，而值则可以是字符串对象（string）、列表对象（list）、哈希对象（hash）、集合对象（set）或者有序集合对象（zset）的其中一种。Redis中对象（redisObject）结构表示如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d53047e5ad04d61ab4f34566f96feb9~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><ul><li>类型：包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。可使用<code>TYPE key</code>命令查看值对象的类型。</li><li>编码：记录了对象所使用的编码。可使用<code>OBJECT ENCODING key</code>查看值对象的编码。</li><li>ptr指针：指向对象的底层实现数据结构。</li></ul></blockquote><p>下图展示了每种类型的对象可以使用的编码。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da9e9e16283a4e5a814c7d70c8c912a3~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>使用<code>OBJECT ENCODING key</code>命令可以查看一个数据库键的值对象的编码</p></blockquote><p>通过encoding属性来设定对象所使用的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><blockquote><p>在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。</p></blockquote><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>或者<code>embstr</code>。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void* 转换成long），并将字符串对象的编码设置为int。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li></ul><blockquote><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，而<code>raw</code>编码会调用两次内存分配函数来分别创建。释放<code>embstr</code>编码字符串也只需要一次调用。</p></blockquote><p>字符串对象保存各种不同类型的值所使用的编码方式如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8812775c3546858e0248623fde6105~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><ul><li>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</li><li>Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以embstr编码的字符串对象实际上是只读的。</li><li>当对修改embstr编码的字符串对象时，会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li><li>embstr编码的字符串对象在修改之后，总会变成一个raw编码的字符串对象。</li></ul><h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p>下图列举了一些字符串命令在不同编码的字符串对象下的实现方法。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f2b8c81de2840de89f45efa103e3d34~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>在Redis3.2之前，列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。在Redis3.2之后，统一用<code>quicklist</code>来存储列表对象。执行<code>RPUSH</code>命令，那么服务器将创建一个列表对象作为numbers键的值，下面将分别展示<code>ziplist</code>、<code>linkedlist</code>数据结构。</p><blockquote><p>quicklist存储了一个双向列表，每个列表的节点是一个ziplist，所以实际上quicklist就是linkedlist和ziplist的结合</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d09943f94cc44618955c6256c2954e9~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li>ziplist编码对象如图所示：</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd27aad45d314372bb17f65404c59d29~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li>linkedlist编码的列表对象如图所示：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff154176c78e4c6fa27f6bd2cbcc33bb~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>上图简化了字符串对象的表示方式。</p></blockquote><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</li></ul><blockquote><p>可通过<code>list-max-ziplist-value</code>选项和<code>list-max-ziplist-entries</code>选项修改以上两个条件的上限值</p></blockquote><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p><ul><li><code>ziplist</code>编码的哈希对象使用压缩列表作为底层实现，新的键、值会以两个相邻的压缩列表节点推入到压缩列表表尾。举个例子，如果我们执行以下命令：</li></ul><pre><code>redis&gt; HSET profile name tomredis&gt; HSET profile age 25redis&gt; HSET profile career Programmer</code></pre><p>对象所使用的压缩列表如图</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb3785199e440d69f446ecaa6141982~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><code>hashtable</code>编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存。还是拿上面的命令举例，其结构如图所示：</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe04b94992694c7f856268f2a26269a6~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用<code>ziplist</code>编码，否则使用<code>hashtable</code>编码。</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个。</li></ul><blockquote><p>可通过<code>hash-max-ziplist-value</code>选项和<code>hash-max-ziplist-entries</code>选项修改以上两个条件的上限值</p></blockquote><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p><ul><li>intset编码的集合对象包含的所有元素都被保存在整数集合里面；</li><li>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</li></ul><p>下图分别为intset编码集合对象以及hashtable编码集合对象结构：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9d8c0f0cea474f934670daf7efcc0b~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码，否则使用hashtable编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><blockquote><p>可通过<code>set-max-intset-entries</code>选项修改以上条件上限值</p></blockquote><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。</p><ul><li>ziplist编码的有序集合，使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。集合元素按分值从小到大进行排序。</li><li>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典（<code>dict</code>）和一个跳跃表（<code>zsl</code>）。这两种数据结构都会通过指针来共享相同元素的成员和分值，不会浪费额外的内存。</li></ul><blockquote><ul><li><code>zsl跳跃表</code>按分值从小到大保存了所有集合元素：跳跃表节点的object属性保存了元素的成员，score属性则保存了元素的分值，以便程序可以对有序集合进行范围型操作，比如<code>ZRANK</code>、<code>ZRANGE</code>等命令。</li><li><code>dict字典</code>为有序集合创建了一个从成员到分值的映射：字典的键保存了元素的成员，值保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值，比如<code>ZSCORE</code>命令。</li></ul></blockquote><h4 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist编码：</p><ul><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节。</li></ul><blockquote><p>可通过<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>选项修改以上两个条件的上限值</p></blockquote><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令基本上可以分为两种类型：</p><ul><li>可以对任何类型的键执行（<code>命令多态</code>），比如说DEL、EXPIRE、RENAME、TYPE、OBJECT等。redis会根据键的值对象所使用的编码来选择正确的命令。</li><li>只能对特定类型的键执行，比如SET、GET、RPUSH、LPOP、ZADD、ZCARD等。redis通过redisObject结构的type属性来检查键的值对象是否为执行命令所需的类型，如不匹配则不执行。（<code>类型检查</code>）</li></ul><h3 id="内存回收与对象共享"><a href="#内存回收与对象共享" class="headerlink" title="内存回收与对象共享"></a>内存回收与对象共享</h3><ul><li>Redis通过在对象系统中构建了一个引用计数技术实现的内存回收机制。每个对象的引用计数信息由<code>redisObject</code>结构的<code>refcount</code>属性记录</li><li>Redis会在初始化服务器时，创建0-9999的字符串对象，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</li></ul><blockquote><p>可以通过修改redis.h/REDIS_SHARED_INTEGERS来修改创建共享字符串对象的数量</p></blockquote><h4 id="为什么Redis不共享包含字符串的对象？"><a href="#为什么Redis不共享包含字符串的对象？" class="headerlink" title="为什么Redis不共享包含字符串的对象？"></a>为什么Redis不共享包含字符串的对象？</h4><p>一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多。</p><ul><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N²）。</li></ul><p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p><h4 id="为什么Redis引用计数不会出现循环引用？"><a href="#为什么Redis引用计数不会出现循环引用？" class="headerlink" title="为什么Redis引用计数不会出现循环引用？"></a>为什么Redis引用计数不会出现循环引用？</h4><p>redis对象之间没有深层次的嵌套，顶多有一个指向底层的实现数据结构的指针，并且redis只共享0-9999的数值字符串对象，对于别的对象，ptr指针是不会去寻找是否有相同的，然后指向，所以不存在循环引用。</p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p><code>redisObject</code>除了前面介绍过的<code>type</code>、<code>encoding</code>、<code>ptr</code>和<code>refcount</code>四个属性之外，还包含最后一个属性为<code>lru</code>属性，当用于LRU时表示最后一次访问时间，当用于LFU时，高16位记录分钟级别的访问时间，低8位记录访问频率0到255。</p><p>当服务器打开了<code>maxmemory</code>选项，并且服务器用于回收内存的算法为<code>volatile-lru</code>或者<code>allkeys-lru</code>时，当服务器占用的内存数超过maxmemory所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><blockquote><p>Bitmap、Stream、Geo、HyperLogLog待更新</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Redis设计与实现》（黄健宏）</li><li><a href="https://blog.csdn.net/zwx900102/article/details/109595508">https://blog.csdn.net/zwx900102/article/details/109595508</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> sds </tag>
            
            <tag> 跳跃表 </tag>
            
            <tag> quicklist </tag>
            
            <tag> skiplist </tag>
            
            <tag> ziplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP、HTTPS协议详解</title>
      <link href="2019/04/03/https-detail-explain/"/>
      <url>2019/04/03/https-detail-explain/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>早期以信息发布为主的Web 1.0时代，HTTP已可以满足绝大部分需要。证书费用、服务器的计算资源都比较昂贵，作为HTTP安全扩展的HTTPS，通常只应用在登录、交易等少数环境中。但随着越来越多的重要业务往线上转移，网站对用户隐私和安全性也越来越重视。对于防止恶意监听、中间人攻击、恶意劫持篡改，HTTPS是目前较为可行的方案，全站HTTPS逐渐成为主流网站的选择。</p><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP（HyperText Transfer Protocol，超文本传输协议）,是一种<code>无状态 (stateless)</code> 协议，提供了一组规则和标准，从而让信息能够在互联网上进行传播。在HTTP中，客户端通过Socket创建一个TCP/IP连接，并连接到服务器，完成信息交换后，就会关闭TCP连接。（后来通过<code>Connection: Keep-Alive</code>实现长连接）</p><h3 id="HTTP消息组成："><a href="#HTTP消息组成：" class="headerlink" title="HTTP消息组成："></a>HTTP消息组成：</h3><ul><li>请求行或响应行</li><li>HTTP头部</li><li>HTML实体，包括请求实体和响应实体<br>HTTP请求结构，响应结构如图所示：</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d0bd30cac2a4faeadfb2ef8953a843e~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="1-HTTP头部"><a href="#1-HTTP头部" class="headerlink" title="1. HTTP头部"></a>1. HTTP头部</h4><p>HTTP头部由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，如：<code>accept、accept-encoding、cookie</code>等。http头后面必须有一个空行</p><h4 id="2-请求行"><a href="#2-请求行" class="headerlink" title="2. 请求行"></a>2. 请求行</h4><p>请求行由方法、URL、HTTP版本组成。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20491a699b7b4e4c946d006228d85b58~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="3-响应行"><a href="#3-响应行" class="headerlink" title="3. 响应行"></a>3. 响应行</h4><p>响应行由HTTP版本、状态码、信息提示符组成。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24151074aa544d4996bd291f81a4866~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><ul><li><p>新的二进制格式，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p>多路复用，所有请求共享一个连接。每个请求会对应一个id，这样，一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的<code>id</code>将请求再归属到各自不同的服务端请求里面。</p></li><li><p>header压缩，HTTP1.x的<code>header</code>带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份<code>header fields</code>表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p>服务端推送，同<code>SPDY</code>一样，HTTP2.0也具有<code>server push</code>功能。</p></li></ul><h3 id="HTTP安全问题"><a href="#HTTP安全问题" class="headerlink" title="HTTP安全问题"></a>HTTP安全问题</h3><ul><li>通信使用明文(不加密),内容可能会被窃听</li><li>不验证通信方的身份,因此有可能遭遇伪装</li><li>无法证明报文的完整性,所以有可能已遭篡改</li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS 是最流行的 HTTP 安全形式。使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送到网络之前，都要进行加密。 HTTPS 在 HTTP 下面提供了一个传输级的密码安全层——可以使用 SSL，也可以使用其后继者——传输层安全(TLS)。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6501ef57e7024c32a816f84b9d6e4085~tplv-k3u1fbpfcp-zoom-1.image"></p><p>相关术语</p><ul><li>密钥：改变密码行为的数字化参数。</li><li>对称密钥加密系统：编、解码使用相同密钥的算法。</li><li>不对称密钥加密系统：编、解码使用不同密钥的算法。</li><li>公开密钥加密系统：一种能够使数百万计算机便捷地发送机密报文的系统。</li><li>数字签名：用来验证报文未被伪造或篡改的校验和。</li><li>数字证书：由一个可信的组织验证和签发的识别信息。</li><li>密钥协商算法：解决动态密钥分配、存储、传输等问题</li></ul><h3 id="TLS-SSL协议"><a href="#TLS-SSL协议" class="headerlink" title="TLS/SSL协议"></a>TLS/SSL协议</h3><p>TLS/SSL协议包含以下一些关键步骤：</p><ul><li>传输的数据必须具有<code>机密性</code>和<code>完整性</code>，一般采用<code>对称加密算法</code>和<code>HMAC算法</code>，这两个算法需要一系列的<code>密钥块（key_block）</code>，比如对称加密算法的密钥、HMAC算法的密钥，如果是AES-128-CBC-PKCS#7加密标准，还需要初始化向量。</li><li>所有的加密块都由<code>主密钥（Master Secret）</code>生成，主密钥就是会话密钥，使用密码衍生算法将主密钥转换为多个密码快。</li><li>主密钥来自<code>预备主密钥（Premaster Secret）</code>，预备主密钥采用同样的密码衍生算法转换为主密钥，预备主密钥采用RSA或者DH（ECDH）算法协商而来。不管采用哪种密钥协商算法，服务器必须有一对密钥（可以是RSA或者ECDSA密钥），公钥发给客户端，私钥自己保留。不同的密钥协商算法，服务器密钥对的作用也是不同的。</li><li>通过这些关键步骤，好像TLS/SSL协议的任务已经结束，但这种方案会遇到中间人攻击，这是TLS/SSL协议无法解决的问题，必须结合<code>PKI</code>的技术进行解决，PKI的核心是证书，证书背后的密码学算法是<code>数字签名</code>技术。对于客户端来说，需要校验证书，确保接收到的服务器公钥是经过认证的，不存在伪造，也就是客户端需要对服务器的身份进行验证。</li></ul><p>TLS/SSL协议核心就三大步骤：<code>认证、密钥协商、数据加密</code>。</p><h3 id="RSA握手"><a href="#RSA握手" class="headerlink" title="RSA握手"></a>RSA握手</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6147f92dc7184d5895d364509f2ea63f~tplv-k3u1fbpfcp-zoom-1.image"></p><p>握手阶段分成五步：</p><ol><li>客户端给出协议版本号、生成的<code>随机数（Client random）</code>，以及客户端支持的加密方法。</li><li>服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数。</li><li>客户端确认数字证书有效，然后生成一个新的<code>随机数（Premaster secret）</code>，并使用数字证书中的公钥，加密这个随机数，发给服务器。</li><li>服务器使用自己的私钥，获取客户端发来的<code>随机数（Premaster secret）</code>。</li><li>双方根据约定的加密方法，使用前面的三个随机数，生成<code>会话密钥（session key）</code>，用来加密接下来的对话过程。</li></ol><p>握手阶段有三点需要注意：</p><ol><li>生成对话密钥一共需要<code>三个随机数</code>。</li><li>握手之后的对话使用<code>对话密钥（session key）</code>加密（对称加密），服务器的<code>公钥</code>和<code>私钥</code>只用于<code>加密和解密对话密钥（session key）</code>（非对称加密），无其他作用。</li><li>服务器<code>公钥</code>放在服务器的<code>数字证书</code>之中。</li></ol><h3 id="DH握手"><a href="#DH握手" class="headerlink" title="DH握手"></a>DH握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4668c8c48f9f43ca9c46d5b14b9b0af5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>RSA整个握手阶段都不加密，都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于<code>第三个随机数（Premaster secret）</code>能不能被破解。为了足够安全，我们可以考虑把握手阶段的算法从默认的<code>RSA</code>算法，改为 <code>Diffie-Hellman</code>算法（简称DH算法）。采用DH算法后，<code>Premaster secret</code>不需要传递，双方只要交换各自的参数，就可以算出这个随机数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入浅出HTTPS：从原理到实战》（虞卫东）</li><li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a></li><li><a href="https://segmentfault.com/a/1190000011675421">https://segmentfault.com/a/1190000011675421</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> https </category>
          
          <category> 网络 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
            <tag> TLS </tag>
            
            <tag> SSL </tag>
            
            <tag> RSA握手 </tag>
            
            <tag> DH握手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学初探</title>
      <link href="2019/04/02/cryptography-preliminary-learn/"/>
      <url>2019/04/02/cryptography-preliminary-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h2><p>密码学有着严格的规范，其算法的实现原理是公开的。密码学算法是相对安全的，主要解决四个问题：</p><ul><li>机密性（隐私性）：在网络中传递的数据如果具备机密性，只有拥有密钥的才能解释这些数据，密钥是加密算法的关键。</li><li>完整性：接收方能够确保接收到的数据就是发送方发送的原始数据，在密码学中，主要使用消息验证码（<code>MAC</code>）算法保证完整性。</li><li>身份验证：通信双方必须确保对端就是要通信的对象。在密码学中，一般使用数字签名技术确认身份。</li><li>不可抵赖性：在密码学中，数字签名技术能够避免抵赖。</li></ul><blockquote><p>OpenSSL：是<code>SSL</code>和<code>TLS</code>最常见的开源实现，包括了底层密码库和命令行工具，其目标是开发一个强壮的、具有完备功能的商业级工具集，以实现<code>SSL</code>和<code>TLS</code>协议以及一个全功能的通用加密库。</p></blockquote><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="随机数的类型"><a href="#随机数的类型" class="headerlink" title="随机数的类型"></a>随机数的类型</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61ede967e5d747e388b79cf5f443ce42~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="随机数的工作原理"><a href="#随机数的工作原理" class="headerlink" title="随机数的工作原理"></a>随机数的工作原理</h3><p>随机数生成器内部会维护一个<code>状态（internal state）</code>，对于随机数生成器（TRNG）来说，内部状态的数值来自外部设备，称为<code>熵（entrory）</code>，比如动态的时间、变化的温度、声音的变化、鼠标位置。而对于<code>伪随机数生成器（PRNG）</code>来说，内部状态的数值来自于模拟的数值，称为<code>种子（seed）</code>。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的。</p><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>由于<code>Hash算法</code>有很多功能，比如<code>摘要算法（Message DigestAlgorithms）、单向散列函数（Cryptographic One-way Hash Functions）</code>。输出值也有多种称呼，比如<code>摘要值、散列、指纹</code>。<code>密码学Hash算法</code>是非常重要的一个算法，是现代密码学中的核心组成部分，其主要特性如下：</p><ul><li>相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值<code>长度是相同</code>的。</li><li>不管多长的消息，Hash运算非常快速。</li><li>通过摘要值很难逆向计算出原始消息，Hash算法具备<code>单向性</code>，摘要值是不可逆的。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。</li><li>原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。</li><li>很难找出两个不同的消息，并且它们的摘要值是相同的。<blockquote><p>密码学Hash算法有很多，比如<code>MD5算法、SHA族类算法</code>，MD5早已被证明是不安全的Hash算法了，目前使用最广泛的Hash算法是SHA族类算法。</p></blockquote></li></ul><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>通过一个算法和一个<code>密钥（secret key）</code>对<code>明文（plaintext）</code>进行处理，得到的不规则字符就是<code>密文（ciphertext）</code>。对称加密算法有两种类型，分别是<code>块密码算法（block ciphers）</code>和<code>流密码算法（stream ciphers）</code>。<code>AES、DES、3DES</code>等是常见的对称加密算法。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/653905e353ab4f999f274f09f6bf5658~tplv-k3u1fbpfcp-zoom-1.image"></p><p>对称加密算法可以用下列公式简单表述：</p><blockquote><p>密文=E（明文，算法，密钥）</p><p>明文=D（密文，算法，密钥）</p></blockquote><p>E和D分别表示加密和解密，通过公式可以了解几个关键点：</p><ul><li>密钥是关键，密钥是一串数字，加密和解密使用同样的一个密钥，如果没有密钥，基于密文是无法获取明文的。</li><li>加密和解密操作（算法）是一个互逆过程，算法的背后就是复杂的数学知识。</li></ul><h2 id="消息验证码"><a href="#消息验证码" class="headerlink" title="消息验证码"></a>消息验证码</h2><p>Hash算法能够完成密码学目标之一的完整性校验，但却不能避免消息被篡改，为避免消息被篡改，需要用到<code>消息验证码（MAC）</code>。消息验证码非常重要，一般结合加密算法一起使用。消息验证码算法具有如下特点：</p><ul><li>证明消息没有被篡改，这和Hash算法类似。</li><li>消息是正确的发送者发送的，也就是说消息是经过验证的。</li></ul><p>通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。过程图如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/065710df132b47c3bb6192a78582fccb~tplv-k3u1fbpfcp-zoom-1.image"></p><p>消息认证实际上是对消息本身产生一个冗余的信息－<code>MAC（消息认证码）</code>，消息认证码是利用密钥对要认证的消息产生新的数据块并对数据块加密生成的。它对于要保护的信息来说是唯一和一一对应的。因此可以有效地保护消息的<code>完整性</code>，以及实现发送方消息的不能伪造。</p><h2 id="公开密钥算法（非对称加密）"><a href="#公开密钥算法（非对称加密）" class="headerlink" title="公开密钥算法（非对称加密）"></a>公开密钥算法（非对称加密）</h2><p>公开密钥算法表示密钥可以部分公开，公开密钥算法的密钥是一对，分别是<code>公钥（public key）</code>和<code>私钥（private key）</code>，一般私钥由密钥对的生成方（比如服务器端）持有，避免泄露，而公钥任何人都可以持有，也不怕泄露。公开密钥算法的功能比较多，可以进行<code>加密解密、密钥协商、数字签名</code>。公开密钥算法最重要和最广泛的就是<code>RSA算法</code>。相比对称加密算法来说，公开密钥算法尤其是<code>RSA算法</code>运算非常缓慢，加解密过程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12037d63c7ac4721b189c6a2204d6477~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="密钥协商算法"><a href="#密钥协商算法" class="headerlink" title="密钥协商算法"></a>密钥协商算法</h2><p>在网络通信应用中，密钥的管理和分配是个难题，尤其是生成一个动态密钥更难，而密钥协商算法就可以解决密钥分配、存储、传输等问题。</p><h3 id="RSA密钥协商算法"><a href="#RSA密钥协商算法" class="headerlink" title="RSA密钥协商算法"></a>RSA密钥协商算法</h3><p>通过一个例子看看<code>RSA密钥协商算法</code>如何工作的：</p><ul><li>客户端初始化连接服务器端，服务器发送<code>RSA密钥对的公钥</code>给客户端。</li><li>客户端生成一个<code>随机值</code>，这个值必须是随机的，不能被攻击者猜出，这个值就是<code>会话密钥</code>。</li><li>客户端使用服务器<code>RSA密钥对的公钥</code>加密会话密钥，并发送给服务器端，由于攻击者没有服务器的私钥，所以无法解密会话密钥。</li><li>服务器端用它的<code>私钥</code>解密出会话密钥。</li><li>至此双方完成连接，接下来服务器端和客户端可以使用<code>对称加密算法</code>和<code>会话密钥</code>加密解密数据。</li></ul><h3 id="DH密钥协商算法"><a href="#DH密钥协商算法" class="headerlink" title="DH密钥协商算法"></a>DH密钥协商算法</h3><p>DH算法确切地说，实现的是<code>密钥交换</code>或者<code>密钥协商</code>，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个<code>会话密钥</code>，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能<code>共同</code>计算出相同的会话密钥。DH算法处理过程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3317db293d174c2da7d3bbd326396d05~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><code>RSA签名算法</code>和<code>DSA签名算法</code>都可以实现数字签名，数字签名技术能够进行身份验证，防止抵赖、防止篡改、防止伪造。数字签名流程如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc91aaad5cf4c27aad79cfaa0eb82cd~tplv-k3u1fbpfcp-zoom-1.image"></p><p>数字签名技术的本质不是为了加密，所以和签名值一同传递的消息是不用加密的，当然也可以对消息加密后再计算签名值。签名验证流程如图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafec67388404352a9ffc7a126ad7948~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>考虑到公开密钥算法运行是相对缓慢的，数字签名算法建议对消息摘要值进行签名，因为摘要值的长度是固定的，运算的时候速度会比较快。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入浅出HTTPS：从原理到实战》（虞卫东）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> 对称加密 </tag>
            
            <tag> 非对称加密 </tag>
            
            <tag> 随机数 </tag>
            
            <tag> 消息验证码 </tag>
            
            <tag> RSA </tag>
            
            <tag> DH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络、TCP原理</title>
      <link href="2019/03/21/principle-of-network-tcp/"/>
      <url>2019/03/21/principle-of-network-tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01e6973a8daa42aeba5d48b9c49fa19b~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><p>应用层：通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程间通信和交互的规则。应用层交互的数据单元成为报文。常用应用层协议有HTTP、DNS、FTP、SMTP。</p></li><li><p>运输层：运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。运输层主要使用以下两种协议：</p><blockquote><p>TCP：提供面向连接的、可靠的数据传输服务，其数据传输单位是报文段。</p><p>UDP：提供无连接的、尽最大努力的数据传输服务，其数据传输的单位是用户数据报</p></blockquote></li><li><p>网络层：选择合适的网间路由和交换结点，为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送</p><blockquote><p>网络层只向上提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网际协议IP是TCP/IP体系中最主要的协议之一，与其配套使用的还有ARP、ICMP、IGMP。</p></blockquote></li><li><p>数据链路层：使用专门的链路层的协议在两台主机上一段一段的传输数据。数据链路层将网络层交下来的 IP 数据报组装成帧（加上帧头和帧尾），在两个相邻节点间的链路上传送。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><blockquote><p>数据链路层使用CRC检验实现无比特差错的传输。对于通信质量良好的有线链路，链路层协议不使用确认和重传机制，改正差错的任务由上层协议完成。对于通信质量较差的无线链路，数据链路层使用确认和重传机制向上提供可靠传输服务。</p></blockquote></li><li><p>物理层：在物理层上所传送的数据单位是比特。其实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</p></li></ul><h2 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d80a3ad092424604a383714dca896d00~tplv-k3u1fbpfcp-zoom-1.image"></p><p>主机1的应用进程AP1向主机2的应用进程AP2传送数据:</p><ul><li>AP1先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H5就变成了下一层的数据单元。</li><li>第4层（运输层）收到这个数据单元后，加上本层的控制信息H4，再交给第3层（网络层），成为第3层的数据单元。<br>依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li></ul><p>当这一串的比特流离开主机1的物理层经网络的物理媒体（传输信道）传送到路由器时，就从路由器的第1层（物理层）依次上升到第3层（网络层）。每一层都是根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的路由表，找出转发分组的接口，然后往下传送到第2层（链路层），加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</p><p>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP1发送的数据交给目的站的应用进程AP2。</p><h2 id="TCP详解"><a href="#TCP详解" class="headerlink" title="TCP详解"></a>TCP详解</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534bd90b21ab4993b4e2ae690c8f6073~tplv-k3u1fbpfcp-zoom-1.image"></p><h5 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h5><blockquote><p>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p></blockquote><h5 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h5><blockquote><p>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p></blockquote><h5 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h5><blockquote><p>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e174cf7bf489462c876dd2762e41ccdb~tplv-k3u1fbpfcp-zoom-1.image"></p><p>对于一个已经建立的连接，TCP使用改进的四次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p><h5 id="第一次-1"><a href="#第一次-1" class="headerlink" title="第一次"></a>第一次</h5><blockquote><p>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p></blockquote><h5 id="第二次-1"><a href="#第二次-1" class="headerlink" title="第二次"></a>第二次</h5><blockquote><p>主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p></blockquote><h5 id="第三次-1"><a href="#第三次-1" class="headerlink" title="第三次"></a>第三次</h5><blockquote><p>主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p></blockquote><h5 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h5><blockquote><p>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p></blockquote><h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p>自动重传请求（Automatic Repeat-reQuest，ARQ），它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。接收方收到重复的分组也会发送确认帧。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><blockquote><p>停止等待协议：每次发完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个请求。</p><p>连续ARQ协议：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p></blockquote><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接受。TCP 利用滑动窗口实现流量控制。</p><blockquote><p>持续计时器：为解决在传输期间，非零窗口通知丢失，而导致互相等待的死锁局面。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p></blockquote><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。进行拥塞控制的四种算法如下：</p><ul><li><p>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p></li><li><p>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p></li><li><p>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cffae4b0e7fc411d8e04869b91142b60~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8481bb0041c416da98fcb1f99361a52~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《图解HTTP》</li><li>《计算机网络第七版》（谢希仁编著）</li><li><a href="https://snailclimb.gitee.io/javaguide">https://snailclimb.gitee.io/javaguide</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> tcp </tag>
            
            <tag> 三次握手 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
