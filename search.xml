<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis底层数据结构</title>
      <link href="2019/04/10/redis-base-data-structure/"/>
      <url>2019/04/10/redis-base-data-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99f86da38c04d69b8ec536dc18e2cce~tplv-k3u1fbpfcp-watermark.image"></p><p>相较于C字符串的优点：</p><ul><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出。C字符串不记录自身长度容易造成缓冲区溢出，SDS修改时，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</li><li>减少修改字符串时带来的内存重分配次数。SDS采用空间预分配（<code>增长操作</code>）和惰性释放（<code>缩短操作</code>）</li><li>二进制安全。C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。SDS可以保存任意格式的二进制数据。</li><li>兼容部分C字符串函数，避免了不必要的代码重复。</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表被广泛用于实现Redis的各种功能，比如列表、发布与订阅、慢查询、监视器等。</p><p>listNode结构：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e12c7c8de42429ea58227a4a6d0c50a~tplv-k3u1fbpfcp-watermark.image"></p><p>多个listNode可以通过prev和next指针组成双端链表。</p><p>list结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0a259d12fb64aeeab93a15e17d45b14~tplv-k3u1fbpfcp-watermark.image"></p><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>一个list结构和三个listNode结构组成的链表：</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887260df9ff64595af3e3c5e95161b8c~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表</p></blockquote><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis的字典使用哈希表作为底层实现，哈希表结构如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68011abde49341be901285c26f318d51~tplv-k3u1fbpfcp-watermark.image"></p><p>一个大小为4的空哈希表（没有包含任何键值对）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd8fe7761a94fb9b93f3f1fb7f19c2f~tplv-k3u1fbpfcp-watermark.image"></p><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ce0dcb537494dd5beba88a80ea2c2ac~tplv-k3u1fbpfcp-watermark.image"></p><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p><p>Redis中的字典的结构：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9833d98c574a0b8f71ff43e16ce3f9~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>为了避免rehash对服务器性能造成影响，服务器不是一次性将哈希表中所有键值对全部rehash到新的哈希表，而是分多次、渐进式地将完成rehash。</p><p>以下是哈希表渐进式rehash的详细步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><blockquote><p>在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。新添加到字典的键值对一律会被保存到ht[1]里面。</p></blockquote><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。Redis使用跳跃表作为有序集合键的底层实现之一。</p><p>zskiplistNode结构如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65aec15a9cf649d98c5dad5237a75b60~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><ul><li>level：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>backward指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>score：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>obj：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul></blockquote><p>zskiplist结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7238607e6544338799ccc424ec686d~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul></blockquote><p>带有zskiplist结构的跳跃表</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12c991edc344472a99551446c4ac15b0~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。整数集合结构如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d155c452e8b94235ab129aaca98d062d~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>升级：每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。不支持降级操作。</p></blockquote><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（ziplist）是列表和哈希的底层实现之一。当一个列表只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表的底层实现。压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。压缩表组成部分：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d5b5e9025c43f880ee12fc4f9a6c68~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><ul><li>zlbytes：记录整个压缩列表占用的内存字节数。在对压缩列表进行内存重分配或者计算zlend的位置时使用。</li><li>zltails：记录压缩列表表尾结点距离压缩列表的起始地址有多少字节。通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾结点的地址。</li><li>zllen：记录了压缩列表包含的节点数量。</li><li>entryX：压缩列表所包含的节点。</li><li>zlend：用于标记压缩列表的末端。</li></ul></blockquote><p>下图展示一个压缩列表的示例：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2430bbbc3fc54718980a91f249023e70~tplv-k3u1fbpfcp-watermark.image"></p><p>压缩列表节点：由previous_entry_length、encoding、content三个部分组成。</p><blockquote><ul><li>previous_entry_length：记录了压缩列表中前一个节点的长度。程序可以通过指针减去当前节点的previous_entry_length，来计算出前一个节点的起始地址。</li><li>encoding：记录了节点的content属性所保存数据的类型以及长度。</li><li>content：保存节点的值。节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</li></ul></blockquote><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，e1至eN的所有节点的previous_entry_length属性都是1字节长的（因为所有节点的长度都小于254字节）。这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点，后面的e1,、e2、e3的previous_entry_length都需要程序对压缩列表执行空间重分配，扩展其长度。Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48bfd730c6e14db2b28f280bbf2c4ca3~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis基于底层数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。Redis的对象系统还实现了基于引用计数技术的内存回收机制和对象共享机制。</p><p>Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。键总是一个字符串对象，而值则可以是字符串对象（string）、列表对象（list）、哈希对象（hash）、集合对象（set）或者有序集合对象（zset）的其中一种。Redis中对象（redisObject）结构表示如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d53047e5ad04d61ab4f34566f96feb9~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><ul><li>类型：包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。<code>TYPE key</code>可以查看值对象的类型。</li><li>编码：记录了对象所使用的编码。</li><li>ptr指针：指向对象的底层实现数据结构。</li></ul></blockquote><p>下图展示了每种类型的对象可以使用的编码。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da9e9e16283a4e5a814c7d70c8c912a3~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>使用<code>OBJECT ENCODING key</code>命令可以查看一个数据库键的值对象的编码</p></blockquote><p>通过encoding属性来设定对象所使用的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><blockquote><p>在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。</p></blockquote><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>或者<code>embstr</code>。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void* 转换成long），并将字符串对象的编码设置为int。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li></ul><blockquote><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，而<code>raw</code>编码会调用两次内存分配函数来分别创建。释放<code>embstr</code>编码字符串也只需要一次调用。</p></blockquote><p>字符串对象保存各种不同类型的值所使用的编码方式如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8812775c3546858e0248623fde6105~tplv-k3u1fbpfcp-watermark.image"></p><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。另外，Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以embstr编码的字符串对象实际上是只读的。当对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。</p><h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p>下图列举了一些字符串命令在不同编码的字符串对象下的实现方法。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f2b8c81de2840de89f45efa103e3d34~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist或者linkedlist。执行以下RPUSH命令，那么服务器将创建一个列表对象作为numbers键的值，下面将分别展示ziplist、linkedlist数据结构。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d09943f94cc44618955c6256c2954e9~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>ziplist编码对象如图所示：</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd27aad45d314372bb17f65404c59d29~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>linkedlist编码的列表对象如图所示：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff154176c78e4c6fa27f6bd2cbcc33bb~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>上图简化了字符串对象的表示方式。</p></blockquote><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</li></ul><blockquote><p>可通过<code>list-max-ziplist-value</code>选项和<code>list-max-ziplist-entries</code>选项修改以上两个条件的上限值</p></blockquote><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> sds </tag>
            
            <tag> 跳跃表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP、HTTPS协议详解</title>
      <link href="2019/04/03/https-detail-explain/"/>
      <url>2019/04/03/https-detail-explain/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>早期以信息发布为主的Web 1.0时代，HTTP已可以满足绝大部分需要。证书费用、服务器的计算资源都比较昂贵，作为HTTP安全扩展的HTTPS，通常只应用在登录、交易等少数环境中。但随着越来越多的重要业务往线上转移，网站对用户隐私和安全性也越来越重视。对于防止恶意监听、中间人攻击、恶意劫持篡改，HTTPS是目前较为可行的方案，全站HTTPS逐渐成为主流网站的选择。</p><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP（HyperText Transfer Protocol，超文本传输协议）,是一种<code>无状态 (stateless)</code> 协议，提供了一组规则和标准，从而让信息能够在互联网上进行传播。在HTTP中，客户端通过Socket创建一个TCP/IP连接，并连接到服务器，完成信息交换后，就会关闭TCP连接。（后来通过<code>Connection: Keep-Alive</code>实现长连接）</p><h3 id="HTTP消息组成："><a href="#HTTP消息组成：" class="headerlink" title="HTTP消息组成："></a>HTTP消息组成：</h3><ul><li>请求行或响应行</li><li>HTTP头部</li><li>HTML实体，包括请求实体和响应实体<br>HTTP请求结构，响应结构如图所示：</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d0bd30cac2a4faeadfb2ef8953a843e~tplv-k3u1fbpfcp-watermark.image"></p><h4 id="1-HTTP头部"><a href="#1-HTTP头部" class="headerlink" title="1. HTTP头部"></a>1. HTTP头部</h4><p>HTTP头部由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，如：<code>accept、accept-encoding、cookie</code>等。http头后面必须有一个空行</p><h4 id="2-请求行"><a href="#2-请求行" class="headerlink" title="2. 请求行"></a>2. 请求行</h4><p>请求行由方法、URL、HTTP版本组成。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20491a699b7b4e4c946d006228d85b58~tplv-k3u1fbpfcp-watermark.image"></p><h4 id="3-响应行"><a href="#3-响应行" class="headerlink" title="3. 响应行"></a>3. 响应行</h4><p>响应行由HTTP版本、状态码、信息提示符组成。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24151074aa544d4996bd291f81a4866~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><ul><li><p>新的二进制格式，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p>多路复用，所有请求共享一个连接。每个请求会对应一个id，这样，一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的<code>id</code>将请求再归属到各自不同的服务端请求里面。</p></li><li><p>header压缩，HTTP1.x的<code>header</code>带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份<code>header fields</code>表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p>服务端推送，同<code>SPDY</code>一样，HTTP2.0也具有<code>server push</code>功能。</p></li></ul><h3 id="HTTP安全问题"><a href="#HTTP安全问题" class="headerlink" title="HTTP安全问题"></a>HTTP安全问题</h3><ul><li>通信使用明文(不加密),内容可能会被窃听</li><li>不验证通信方的身份,因此有可能遭遇伪装</li><li>无法证明报文的完整性,所以有可能已遭篡改</li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS 是最流行的 HTTP 安全形式。使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送到网络之前，都要进行加密。 HTTPS 在 HTTP 下面提供了一个传输级的密码安全层——可以使用 SSL，也可以使用其后继者——传输层安全(TLS)。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6501ef57e7024c32a816f84b9d6e4085~tplv-k3u1fbpfcp-watermark.image"></p><p>相关术语</p><ul><li>密钥：改变密码行为的数字化参数。</li><li>对称密钥加密系统：编、解码使用相同密钥的算法。</li><li>不对称密钥加密系统：编、解码使用不同密钥的算法。</li><li>公开密钥加密系统：一种能够使数百万计算机便捷地发送机密报文的系统。</li><li>数字签名：用来验证报文未被伪造或篡改的校验和。</li><li>数字证书：由一个可信的组织验证和签发的识别信息。</li><li>密钥协商算法：解决动态密钥分配、存储、传输等问题</li></ul><h3 id="TLS-SSL协议"><a href="#TLS-SSL协议" class="headerlink" title="TLS/SSL协议"></a>TLS/SSL协议</h3><p>TLS/SSL协议包含以下一些关键步骤：</p><ul><li>传输的数据必须具有<code>机密性</code>和<code>完整性</code>，一般采用<code>对称加密算法</code>和<code>HMAC算法</code>，这两个算法需要一系列的<code>密钥块（key_block）</code>，比如对称加密算法的密钥、HMAC算法的密钥，如果是AES-128-CBC-PKCS#7加密标准，还需要初始化向量。</li><li>所有的加密块都由<code>主密钥（Master Secret）</code>生成，主密钥就是会话密钥，使用密码衍生算法将主密钥转换为多个密码快。</li><li>主密钥来自<code>预备主密钥（Premaster Secret）</code>，预备主密钥采用同样的密码衍生算法转换为主密钥，预备主密钥采用RSA或者DH（ECDH）算法协商而来。不管采用哪种密钥协商算法，服务器必须有一对密钥（可以是RSA或者ECDSA密钥），公钥发给客户端，私钥自己保留。不同的密钥协商算法，服务器密钥对的作用也是不同的。</li><li>通过这些关键步骤，好像TLS/SSL协议的任务已经结束，但这种方案会遇到中间人攻击，这是TLS/SSL协议无法解决的问题，必须结合<code>PKI</code>的技术进行解决，PKI的核心是证书，证书背后的密码学算法是<code>数字签名</code>技术。对于客户端来说，需要校验证书，确保接收到的服务器公钥是经过认证的，不存在伪造，也就是客户端需要对服务器的身份进行验证。</li></ul><p>TLS/SSL协议核心就三大步骤：<code>认证、密钥协商、数据加密</code>。</p><h3 id="RSA握手"><a href="#RSA握手" class="headerlink" title="RSA握手"></a>RSA握手</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6147f92dc7184d5895d364509f2ea63f~tplv-k3u1fbpfcp-watermark.image"></p><p>握手阶段分成五步：</p><ol><li>客户端给出协议版本号、生成的<code>随机数（Client random）</code>，以及客户端支持的加密方法。</li><li>服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数。</li><li>客户端确认数字证书有效，然后生成一个新的<code>随机数（Premaster secret）</code>，并使用数字证书中的公钥，加密这个随机数，发给服务器。</li><li>服务器使用自己的私钥，获取客户端发来的<code>随机数（Premaster secret）</code>。</li><li>双方根据约定的加密方法，使用前面的三个随机数，生成<code>会话密钥（session key）</code>，用来加密接下来的对话过程。</li></ol><p>握手阶段有三点需要注意：</p><ol><li>生成对话密钥一共需要<code>三个随机数</code>。</li><li>握手之后的对话使用<code>对话密钥（session key）</code>加密（对称加密），服务器的<code>公钥</code>和<code>私钥</code>只用于<code>加密和解密对话密钥（session key）</code>（非对称加密），无其他作用。</li><li>服务器<code>公钥</code>放在服务器的<code>数字证书</code>之中。</li></ol><h3 id="DH握手"><a href="#DH握手" class="headerlink" title="DH握手"></a>DH握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4668c8c48f9f43ca9c46d5b14b9b0af5~tplv-k3u1fbpfcp-watermark.image"></p><p>RSA整个握手阶段都不加密，都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于<code>第三个随机数（Premaster secret）</code>能不能被破解。为了足够安全，我们可以考虑把握手阶段的算法从默认的<code>RSA</code>算法，改为 <code>Diffie-Hellman</code>算法（简称DH算法）。采用DH算法后，<code>Premaster secret</code>不需要传递，双方只要交换各自的参数，就可以算出这个随机数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入浅出HTTPS：从原理到实战》（虞卫东）</li><li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a></li><li><a href="https://segmentfault.com/a/1190000011675421">https://segmentfault.com/a/1190000011675421</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> https </category>
          
          <category> 网络 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
            <tag> TLS </tag>
            
            <tag> SSL </tag>
            
            <tag> RSA握手 </tag>
            
            <tag> DH握手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学初探</title>
      <link href="2019/04/02/cryptography-preliminary-learn/"/>
      <url>2019/04/02/cryptography-preliminary-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h2><p>密码学有着严格的规范，其算法的实现原理是公开的。密码学算法是相对安全的，主要解决四个问题：</p><ul><li>机密性（隐私性）：在网络中传递的数据如果具备机密性，只有拥有密钥的才能解释这些数据，密钥是加密算法的关键。</li><li>完整性：接收方能够确保接收到的数据就是发送方发送的原始数据，在密码学中，主要使用消息验证码（<code>MAC</code>）算法保证完整性。</li><li>身份验证：通信双方必须确保对端就是要通信的对象。在密码学中，一般使用数字签名技术确认身份。</li><li>不可抵赖性：在密码学中，数字签名技术能够避免抵赖。</li></ul><blockquote><p>OpenSSL：是<code>SSL</code>和<code>TLS</code>最常见的开源实现，包括了底层密码库和命令行工具，其目标是开发一个强壮的、具有完备功能的商业级工具集，以实现<code>SSL</code>和<code>TLS</code>协议以及一个全功能的通用加密库。</p></blockquote><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="随机数的类型"><a href="#随机数的类型" class="headerlink" title="随机数的类型"></a>随机数的类型</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61ede967e5d747e388b79cf5f443ce42~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="随机数的工作原理"><a href="#随机数的工作原理" class="headerlink" title="随机数的工作原理"></a>随机数的工作原理</h3><p>随机数生成器内部会维护一个<code>状态（internal state）</code>，对于随机数生成器（TRNG）来说，内部状态的数值来自外部设备，称为<code>熵（entrory）</code>，比如动态的时间、变化的温度、声音的变化、鼠标位置。而对于<code>伪随机数生成器（PRNG）</code>来说，内部状态的数值来自于模拟的数值，称为<code>种子（seed）</code>。随机数生成器每次生成随机数的时候，内部状态的值都会变化，这样才能产生不一样的随机数，如果每次熵和种子是一样的，生成的随机数也是相同的。</p><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>由于<code>Hash算法</code>有很多功能，比如<code>摘要算法（Message DigestAlgorithms）、单向散列函数（Cryptographic One-way Hash Functions）</code>。输出值也有多种称呼，比如<code>摘要值、散列、指纹</code>。<code>密码学Hash算法</code>是非常重要的一个算法，是现代密码学中的核心组成部分，其主要特性如下：</p><ul><li>相同的消息总是能得到同样的摘要值，特定的Hash算法，不管消息长度是多少，最终的摘要值<code>长度是相同</code>的。</li><li>不管多长的消息，Hash运算非常快速。</li><li>通过摘要值很难逆向计算出原始消息，Hash算法具备<code>单向性</code>，摘要值是不可逆的。为了逆向计算出原始消息，唯一的方法就是采用暴力攻击、字典攻击、彩虹表，对不同的消息组合进行迭代运算，运算的结果如果匹配该消息的摘要值，表示该Hash算法不应该用于密码学。</li><li>原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会产生变化。</li><li>很难找出两个不同的消息，并且它们的摘要值是相同的。<blockquote><p>密码学Hash算法有很多，比如<code>MD5算法、SHA族类算法</code>，MD5早已被证明是不安全的Hash算法了，目前使用最广泛的Hash算法是SHA族类算法。</p></blockquote></li></ul><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>通过一个算法和一个<code>密钥（secret key）</code>对<code>明文（plaintext）</code>进行处理，得到的不规则字符就是<code>密文（ciphertext）</code>。对称加密算法有两种类型，分别是<code>块密码算法（block ciphers）</code>和<code>流密码算法（stream ciphers）</code>。<code>AES、DES、3DES</code>等是常见的对称加密算法。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/653905e353ab4f999f274f09f6bf5658~tplv-k3u1fbpfcp-watermark.image"></p><p>对称加密算法可以用下列公式简单表述：</p><blockquote><p>密文=E（明文，算法，密钥）</p><p>明文=D（密文，算法，密钥）</p></blockquote><p>E和D分别表示加密和解密，通过公式可以了解几个关键点：</p><ul><li>密钥是关键，密钥是一串数字，加密和解密使用同样的一个密钥，如果没有密钥，基于密文是无法获取明文的。</li><li>加密和解密操作（算法）是一个互逆过程，算法的背后就是复杂的数学知识。</li></ul><h2 id="消息验证码"><a href="#消息验证码" class="headerlink" title="消息验证码"></a>消息验证码</h2><p>Hash算法能够完成密码学目标之一的完整性校验，但却不能避免消息被篡改，为避免消息被篡改，需要用到<code>消息验证码（MAC）</code>。消息验证码非常重要，一般结合加密算法一起使用。消息验证码算法具有如下特点：</p><ul><li>证明消息没有被篡改，这和Hash算法类似。</li><li>消息是正确的发送者发送的，也就是说消息是经过验证的。</li></ul><p>通信双方可以维护同一个密钥，只有拥有密钥的通信双方才能生成和验证消息验证码，消息验证码算法需要一个密钥，这和对称加密算法是一样的，通信双方在消息传递之前需要获得同样的密钥。过程图如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/065710df132b47c3bb6192a78582fccb~tplv-k3u1fbpfcp-watermark.image"></p><p>消息认证实际上是对消息本身产生一个冗余的信息－<code>MAC（消息认证码）</code>，消息认证码是利用密钥对要认证的消息产生新的数据块并对数据块加密生成的。它对于要保护的信息来说是唯一和一一对应的。因此可以有效地保护消息的<code>完整性</code>，以及实现发送方消息的不能伪造。</p><h2 id="公开密钥算法（非对称加密）"><a href="#公开密钥算法（非对称加密）" class="headerlink" title="公开密钥算法（非对称加密）"></a>公开密钥算法（非对称加密）</h2><p>公开密钥算法表示密钥可以部分公开，公开密钥算法的密钥是一对，分别是<code>公钥（public key）</code>和<code>私钥（private key）</code>，一般私钥由密钥对的生成方（比如服务器端）持有，避免泄露，而公钥任何人都可以持有，也不怕泄露。公开密钥算法的功能比较多，可以进行<code>加密解密、密钥协商、数字签名</code>。公开密钥算法最重要和最广泛的就是<code>RSA算法</code>。相比对称加密算法来说，公开密钥算法尤其是<code>RSA算法</code>运算非常缓慢，加解密过程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12037d63c7ac4721b189c6a2204d6477~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="密钥协商算法"><a href="#密钥协商算法" class="headerlink" title="密钥协商算法"></a>密钥协商算法</h2><p>在网络通信应用中，密钥的管理和分配是个难题，尤其是生成一个动态密钥更难，而密钥协商算法就可以解决密钥分配、存储、传输等问题。</p><h3 id="RSA密钥协商算法"><a href="#RSA密钥协商算法" class="headerlink" title="RSA密钥协商算法"></a>RSA密钥协商算法</h3><p>通过一个例子看看<code>RSA密钥协商算法</code>如何工作的：</p><ul><li>客户端初始化连接服务器端，服务器发送<code>RSA密钥对的公钥</code>给客户端。</li><li>客户端生成一个<code>随机值</code>，这个值必须是随机的，不能被攻击者猜出，这个值就是<code>会话密钥</code>。</li><li>客户端使用服务器<code>RSA密钥对的公钥</code>加密会话密钥，并发送给服务器端，由于攻击者没有服务器的私钥，所以无法解密会话密钥。</li><li>服务器端用它的<code>私钥</code>解密出会话密钥。</li><li>至此双方完成连接，接下来服务器端和客户端可以使用<code>对称加密算法</code>和<code>会话密钥</code>加密解密数据。</li></ul><h3 id="DH密钥协商算法"><a href="#DH密钥协商算法" class="headerlink" title="DH密钥协商算法"></a>DH密钥协商算法</h3><p>DH算法确切地说，实现的是<code>密钥交换</code>或者<code>密钥协商</code>，DH算法在进行密钥协商的时候，通信双方的任何一方无法独自计算出一个<code>会话密钥</code>，通信双方各自保留一部分关键信息，再将另外一部分信息告诉对方，双方有了全部信息才能<code>共同</code>计算出相同的会话密钥。DH算法处理过程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3317db293d174c2da7d3bbd326396d05~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><code>RSA签名算法</code>和<code>DSA签名算法</code>都可以实现数字签名，数字签名技术能够进行身份验证，防止抵赖、防止篡改、防止伪造。数字签名流程如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc91aaad5cf4c27aad79cfaa0eb82cd~tplv-k3u1fbpfcp-watermark.image"></p><p>数字签名技术的本质不是为了加密，所以和签名值一同传递的消息是不用加密的，当然也可以对消息加密后再计算签名值。签名验证流程如图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafec67388404352a9ffc7a126ad7948~tplv-k3u1fbpfcp-watermark.image"></p><blockquote><p>考虑到公开密钥算法运行是相对缓慢的，数字签名算法建议对消息摘要值进行签名，因为摘要值的长度是固定的，运算的时候速度会比较快。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入浅出HTTPS：从原理到实战》（虞卫东）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> 对称加密 </tag>
            
            <tag> 非对称加密 </tag>
            
            <tag> 随机数 </tag>
            
            <tag> 消息验证码 </tag>
            
            <tag> RSA </tag>
            
            <tag> DH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络、TCP原理</title>
      <link href="2019/03/21/principle-of-network-tcp/"/>
      <url>2019/03/21/principle-of-network-tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01e6973a8daa42aeba5d48b9c49fa19b~tplv-k3u1fbpfcp-watermark.image"></p><ul><li><p>应用层：通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程间通信和交互的规则。应用层交互的数据单元成为报文。常用应用层协议有HTTP、DNS、FTP、SMTP。</p></li><li><p>运输层：运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。运输层主要使用以下两种协议：</p><blockquote><p>TCP：提供面向连接的、可靠的数据传输服务，其数据传输单位是报文段。</p><p>UDP：提供无连接的、尽最大努力的数据传输服务，其数据传输的单位是用户数据报</p></blockquote></li><li><p>网络层：选择合适的网间路由和交换结点，为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送</p><blockquote><p>网络层只向上提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网际协议IP是TCP/IP体系中最主要的协议之一，与其配套使用的还有ARP、ICMP、IGMP。</p></blockquote></li><li><p>数据链路层：使用专门的链路层的协议在两台主机上一段一段的传输数据。数据链路层将网络层交下来的 IP 数据报组装成帧（加上帧头和帧尾），在两个相邻节点间的链路上传送。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><blockquote><p>数据链路层使用CRC检验实现无比特差错的传输。对于通信质量良好的有线链路，链路层协议不使用确认和重传机制，改正差错的任务由上层协议完成。对于通信质量较差的无线链路，数据链路层使用确认和重传机制向上提供可靠传输服务。</p></blockquote></li><li><p>物理层：在物理层上所传送的数据单位是比特。其实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</p></li></ul><h2 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d80a3ad092424604a383714dca896d00~tplv-k3u1fbpfcp-watermark.image"></p><p>主机1的应用进程AP1向主机2的应用进程AP2传送数据:</p><ul><li>AP1先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H5就变成了下一层的数据单元。</li><li>第4层（运输层）收到这个数据单元后，加上本层的控制信息H4，再交给第3层（网络层），成为第3层的数据单元。<br>依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li></ul><p>当这一串的比特流离开主机1的物理层经网络的物理媒体（传输信道）传送到路由器时，就从路由器的第1层（物理层）依次上升到第3层（网络层）。每一层都是根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的路由表，找出转发分组的接口，然后往下传送到第2层（链路层），加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</p><p>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP1发送的数据交给目的站的应用进程AP2。</p><h2 id="TCP详解"><a href="#TCP详解" class="headerlink" title="TCP详解"></a>TCP详解</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534bd90b21ab4993b4e2ae690c8f6073~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h5><blockquote><p>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p></blockquote><h5 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h5><blockquote><p>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p></blockquote><h5 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h5><blockquote><p>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e174cf7bf489462c876dd2762e41ccdb~tplv-k3u1fbpfcp-watermark.image"></p><p>对于一个已经建立的连接，TCP使用改进的四次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p><h5 id="第一次-1"><a href="#第一次-1" class="headerlink" title="第一次"></a>第一次</h5><blockquote><p>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p></blockquote><h5 id="第二次-1"><a href="#第二次-1" class="headerlink" title="第二次"></a>第二次</h5><blockquote><p>主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p></blockquote><h5 id="第三次-1"><a href="#第三次-1" class="headerlink" title="第三次"></a>第三次</h5><blockquote><p>主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p></blockquote><h5 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h5><blockquote><p>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p></blockquote><h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p>自动重传请求（Automatic Repeat-reQuest，ARQ），它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。接收方收到重复的分组也会发送确认帧。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><blockquote><p>停止等待协议：每次发完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个请求。</p><p>连续ARQ协议：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p></blockquote><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接受。TCP 利用滑动窗口实现流量控制。</p><blockquote><p>持续计时器：为解决在传输期间，非零窗口通知丢失，而导致互相等待的死锁局面。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p></blockquote><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。进行拥塞控制的四种算法如下：</p><ul><li><p>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p></li><li><p>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p></li><li><p>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cffae4b0e7fc411d8e04869b91142b60~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8481bb0041c416da98fcb1f99361a52~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《图解HTTP》</li><li>《计算机网络第七版》（谢希仁编著）</li><li><a href="https://snailclimb.gitee.io/javaguide">https://snailclimb.gitee.io/javaguide</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> tcp </tag>
            
            <tag> 三次握手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello hexo</title>
      <link href="2019/03/19/hello-hexo/"/>
      <url>2019/03/19/hello-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>在老早以前，自己就有搭建一个博客的想法，中途也尝试自己动手操作过，但是好几次都半途而废了。在自己的想法中，一个博客需要一套管理系统，自己没那么多时间。最近在晚上搜寻的时候，发现了一个惊为天人的博客，其UI甚合我意，于是一番操作下发现了这个<a href="http://hexo.io/zh-cn/">Hexo</a>，以及那个深得我心的主题-<a href="https://github.com/TriDiamond/hexo-theme-obsidian">obsidian</a>。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>用人话来讲就是，你只管写自己的markdown，那些高大上的渲染以及兼容我会处理好。啊这。。。</p></blockquote><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="所需工具软件"><a href="#所需工具软件" class="headerlink" title="所需工具软件"></a>所需工具软件</h3><ul><li>git : <a href="http://git-scm.com/">http://git-scm.com/</a></li><li>Nodejs : <a href="http://nodejs.org/">http://nodejs.org/</a></li><li>Hexo ： <a href="http://hexo.io/zh-cn/">http://hexo.io/zh-cn/</a></li></ul><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><ul><li><p>git和Nodejs的安装就不说了。</p></li><li><p>安装Hexo</p><pre><code class="bash">$ npm install -g hexo-cli</code></pre></li><li><p>创建hexo文件夹并进入</p><pre><code class="bash">$ hexo init$ npm install</code></pre></li><li><p>启动Hexo服务</p><pre><code class="bash">$ hexo server</code></pre><blockquote><p>浏览器访问：<a href="http://localhost:4000/%EF%BC%8C%E6%AD%A4%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98">http://localhost:4000/，此时使用的是默认主题</a></p></blockquote></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p>下载主题</p><pre><code class="bash">$ git clone https://github.com/TriDiamond/hexo-theme-obsidian.git obsidian</code></pre></li><li><p>修改_config.yml，启用主题</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f20b587aeb5c49eb983c8be2e2f7641e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>更多配置项，请参考<a href="https://hexo.io/zh-cn/docs/configuration.html">这里</a></p></blockquote><ul><li><p>安装主题需要的 NPM 依赖</p><pre><code class="bash">$ cd themes/obsidian$ npm install</code></pre></li><li><p>重新启动</p><pre><code class="bash">$ cd hexo$ hexo s</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 初见 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> obsidian </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
